// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var deferred, myCallback, parseRange;

  myCallback = null;

  parseRange = null;

  deferred = null;

  angular.module('myApp.controllers', []).controller('MyCtrl1', [
    '$scope', '$q', 'jsBridge', 'cm1', 'PPAttributedString', '_', 'Counter', function($scope, $q, jsBridge, cm1, PPAttributedString, _, Counter) {
      cm1.promise.then(function() {
        var display, input, parsee, selectionRangesDataa;
        $('html, body, .ng-view').css({
          'width': '100%',
          'height': '100%',
          'padding': '0',
          'margin': '0'
        });
        display = cm1.display;
        input = display.input;
        cm1.on('change', function(cm, change) {
          var data, parseData;
          data = {};
          data.mode = cm.getMode().name;
          data.docLength = cm.doc.getValue().length;
          data.cursorData = {
            location: cm1.doc.indexFromPos(cm1.doc.getCursor())
          };
          data.selectedRangesData = {
            selectedRanges: selectedRanges()
          };
          if (parseRange) {
            data.parseData = parse(parseRange);
          }
          jsBridge.callHandler('action', data, function(responseData) {});
          if (myCallback) {
            myCallback(data);
          }
          parseData = null;
          myCallback = null;
        });
        jsBridge.registerHandler('request', function(data, callback) {
          var ar, args, attributedRanges, currentMode, e, k, m, mode, newData, parseData, r, range, requests, s, string, tokens, v, _i, _len, _ref, _ref1;
          requests = data.request ? [data.request] : data.requests;
          data = {};
          data.requests = [];
          for (_i = 0, _len = requests.length; _i < _len; _i++) {
            r = requests[_i];
            newData = {};
            newData.request = r.request;
            switch (r.request) {
              case 'tokenize':
                string = r.string;
                mode = r.mode;
                tokens = string && mode ? cm1.tokenize(string, mode) : void 0;
                if (tokens) {
                  newData.tokens = tokens;
                }
                break;
              case 'parse':
                range = r.range ? CSRange.newRangeFromJSON(r.range) : void 0;
                parseData = range ? cm1.parse(range) : void 0;
                if (parseData) {
                  for (k in parseData) {
                    v = parseData[k];
                    newData[k] = v;
                  }
                }
                break;
              case 'replace':
                s = (_ref = r.string) != null ? _ref : null;
                range = r.range ? CSRange.newRangeFromJSON(r.range) : void 0;
                e = (_ref1 = r.event) != null ? _ref1 : null;
                if (s && range) {
                  deferred = $q.defer();
                  deferred.promise.then(function(replaceData) {
                    for (k in replaceData) {
                      v = replaceData[k];
                      newData[k] = v;
                    }
                  });
                  args = {};
                  if (s) {
                    args.string = s;
                  }
                  if (range) {
                    args.range = range;
                  }
                  if (e) {
                    args.event = e;
                  }
                  cm1.replaceCharacters(args);
                }
                break;
              case 'cursor':
                jsBridge.send('This feature (cursor) is not yet implimented.');
                break;
              case 'selectedRanges':
                attributedRanges = r.attributedRange ? [r.attributedRange] : r.attributedRanges;
                if (attributedRanges) {
                  if (attributedRanges.length > 0) {
                    ar = attributedRanges[0];
                    ar = ar.location && ar.length && ar.attributes && ar.attributes.affinity ? new CSAttributedRange(ar) : void 0;
                  } else {
                    ar = new CSAttributedRange(cm1.cursor().location, 0);
                  }
                }
                newData.attributedRanges = ar ? cm1.selectedRanges(ar) : cm1.selectedRanges();
                break;
              case 'mode':
                m = r.mode === 'scss' ? 'text/x-scss' : r.mode;
                currentMode = cm1.getMode().name;
                if (m !== currentMode) {
                  cm1.setOption('mode', m);
                }
                newData.mode = cm1.getMode().name;
            }
            data.requests.push(newData);
          }
          if (deferred) {
            deferred.promise.then(function() {
              callback(newData);
            });
          } else {
            callback(newData);
          }
          deferred = null;
        });
        jsBridge.registerHandler('cursorAndSelectedRannges', function(data, callback) {
          var aff, anchorPos, ar, cd, cl, e, end, headPos, newData, sr, start;
          cd = data.cursor;
          cl = cd != null ? cd.location : void 0;
          sr = data.selectionRanges;
          try {
            if ((cl != null) && typeof cl === 'number') {
              cm1.doc.setCursor(cm1.doc.posFromIndex(cl));
            }
            if (Array.isArray(sr) && sr.length > 0) {
              ar = new CSAttributedRange(sr[0]);
              aff = ar.attributes.affinity;
              start = cm1.doc.posFromIndex(ar.location);
              anchorPos = start;
              headPos = anchorPos;
              if (ar.length > 0 && (aff === 'up' || aff === 'down')) {
                end = cm1.doc.posFromIndex(ar.maxEdge());
                anchorPos = aff === 'down' ? start : end;
                headPos = aff === 'down' ? end : start;
              }
              cm1.doc.setSelection(anchorPos, headPos);
            }
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          newData = {
            cursor: cursorData(),
            selectionRanges: selectionRangesData()
          };
          callback(newData);
        });
        selectionRangesDataa = function() {
          var ar, cursorAnchor, cursorHead, end, selectionRanges, start;
          selectionRanges = [];
          cursorHead = cm1.doc.indexFromPos(cm1.doc.getCursor());
          cursorAnchor = cm1.doc.indexFromPos(cm1.doc.getCursor('anchor'));
          if (cursorAnchor !== cursorHead) {
            start = cm1.doc.indexFromPos(cm1.doc.getCursor('start'));
            end = cm1.doc.indexFromPos(cm1.doc.getCursor('end'));
            ar = new CSAttributedRange({
              location: start,
              length: end,
              attributes: {
                affinity: cursorAnchor < cursorHead ? 'down' : 'up'
              }
            });
            selectionRanges.push(ar);
          }
          return selectionRanges;
        };
        jsBridge.registerHandler('moode', function(data, callback) {
          var currentMode, e, newMode;
          try {
            newMode = data.mode === 'scss' ? 'text/x-scss' : data.mode;
            currentMode = cm1.getMode().name;
            data = {
              mode: currentMode
            };
            if (newMode && newMode !== currentMode) {
              cm1.setOption('mode', newMode);
              data.modeHistory = [currentMode, cm1.getMode().name];
            }
            callback(data);
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          return;
        });
        jsBridge.registerHandler('parseee', function(_data, callback) {
          var data, e, r;
          try {
            r = CSRange.newRangeFromJSON(_data.range);
            data = {};
            data.mode = cm1.getMode().name;
            data.docLength = cm1.doc.getValue().length;
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          data.parseData = parse(r);
          callback(data);
        });
        parsee = function(range) {
          var a, ar, as, attributedRanges, c, cssEl, e, end, globalRanges, pos, r, sel, spanClass, start, token, tokens, tsl, _i, _j, _k, _len, _len1, _len2, _ref;
          try {
            jsBridge.send('parsing range ' + JSON.stringify(range.range()) + ' in mode: ' + JSON.stringify(cm1.getMode().name));
            tokens = [];
            attributedRanges = [];
            c = new Counter({
              i: range.location + 1,
              end: range.maxEdge() + 1
            });
            while (c.i < c.end) {
              pos = cm1.doc.posFromIndex(c.i);
              token = cm1.getTokenAt(pos, {
                precise: true
              });
              tsl = token.string.length;
              ar = attributedRanges[attributedRanges.push(new CSAttributedRange({
                defaultContextName: 'global'
              })) - 1];
              ar.range(cm1.doc.indexFromPos({
                line: pos.line,
                ch: token.start
              }), tsl);
              jsBridge.send('token string: ' + token.string);
              a = ar.attributes;
              a.token = token;
              if (tsl > 0 && (a.token.type != null) && a.token.type !== void 0) {
                sel = [];
                _ref = token.className.split(' ');
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  spanClass = _ref[_i];
                  sel.push('.cm-' + spanClass);
                }
                a.cssSelector = sel[sel.length - 1];
                cssEl = $(a.cssSelector);
                if (cssEl == null) {
                  jsBridge.send('There was a serious error trying to find selector "' + a.cssSelector + '".');
                } else if (cssEl.length === 0) {
                  jsBridge.send('No element could be found with the class "' + a.cssSelector + '". Trying ' + '"' + token.className + '" instead...');
                  cssEl = $(token.className);
                  if (cssEl.length === 0) {
                    jsBridge.send('No element could be found with the class "' + token.className + '" either.');
                  }
                }
                a.color = cssEl.css('color').replace(')', '(').split('(')[1].split(',');
                a.color = {
                  r: a.color[0],
                  g: a.color[1],
                  b: a.color[2]
                };
              } else {
                a.color = $('body').css('color').replace(')', '(').split('(')[1].split(',');
                a.color = {
                  r: a.color[0],
                  g: a.color[1],
                  b: a.color[2]
                };
              }
              jsBridge.send('attributes created at global range: ' + ar.location + ' ' + ar.length);
              tokens.push(token);
              c.incrimentSafelyTo(ar.maxEdge() + 1);
            }
            globalRanges = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = attributedRanges.length; _j < _len1; _j++) {
                ar = attributedRanges[_j];
                _results.push({
                  location: ar.location,
                  length: ar.length,
                  maxEdge: ar.maxEdge()
                });
              }
              return _results;
            })();
            start = _.sortBy(globalRanges, function(r) {
              return r.location;
            })[0].location;
            end = _.sortBy(globalRanges, function(r) {
              return r.maxEdge;
            }).pop().maxEdge;
            r = new CSRange({
              contexts: {
                edited: {
                  location: start,
                  length: end - start,
                  "default": true
                },
                original: CSRange.newRangeFromRange(range)
              }
            });
            for (_j = 0, _len1 = attributedRanges.length; _j < _len1; _j++) {
              ar = attributedRanges[_j];
              ar.c('local', ar.location - r.location, ar.length);
              ar.switchDefaultContext('local');
            }
            jsBridge.send('lr: ' + JSON.stringify(ar.range()) + ' gr: ' + JSON.stringify(ar.c('global').range()));
            as = new PPAttributedString({
              string: doc.getValue().substr(r.c('edited').location, r.c('edited').length)
            });
            for (_k = 0, _len2 = attributedRanges.length; _k < _len2; _k++) {
              ar = attributedRanges[_k];
              as.attributedRanges.push(ar);
            }
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          return {
            attributedString: as,
            tokens: tokens,
            range: r
          };
        };
        jsBridge.send('ready');
      });
    }
  ]).constant('routes', [
    {
      controller: 'MyCtrl1',
      resolve: {
        jsBridge: [
          'jsBridge', function(jsBridge) {
            return jsBridge;
          }
        ],
        myJQ: [
          'myJQ', function(myJQ) {
            return myJQ;
          }
        ]
      }
    }
  ]);

}).call(this);
