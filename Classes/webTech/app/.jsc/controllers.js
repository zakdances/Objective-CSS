// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var myCallback, parseRange;

  parseRange = null;

  myCallback = null;

  angular.module('myApp.controllers', []).controller('MyCtrl1', [
    '$scope', 'jsBridge', 'CMi', 'CM', 'PPAttributedString', '_', function($scope, jsBridge, CMi, CM, PPAttributedString, _) {
      CMi.then(function(CMi) {
        var display, doc, input, parse;
        $('html, body, .ng-view').css({
          'width': '100%',
          'height': '100%',
          'padding': '0',
          'margin': '0'
        });
        doc = CMi.doc;
        display = CMi.display;
        input = display.input;
        CMi.on('change', function(myCM, change) {
          var data, e;
          data = {};
          data.mode = myCM.getMode().name;
          data.docLength = myCM.doc.getValue().length;
          try {
            if (parseRange) {
              data.parseData = parse(parseRange);
              data.parseData.mode = data.mode;
            }
            jsBridge.callHandler('action', data, function(responseData) {});
            if (myCallback) {
              myCallback(data);
            }
            parseRange = null;
            myCallback = null;
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
        });
        jsBridge.registerHandler('mode', function(data, callback) {
          var currentMode, e, newMode;
          try {
            newMode = data.mode === 'scss' ? 'text/x-scss' : data.mode;
            currentMode = CMi.getMode().name;
            data = {
              mode: currentMode
            };
            if (newMode && newMode !== currentMode) {
              CMi.setOption('mode', newMode);
              data.modeHistory = [currentMode, CMi.getMode().name];
            }
            callback(data);
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
        });
        jsBridge.registerHandler('tokenize', function(data, callback) {
          var e, mode, string, tokens;
          mode = data.mode === 'scss' ? 'text/x-scss' : data.mode;
          string = data.string;
          if (!mode) {
            callback({
              error: 'Error: no mode specified'
            });
            return;
          }
          jsBridge.send('tokenizing in ' + mode + ' mode...');
          tokens = [];
          try {
            CM.runMode(string, mode, function(text, styleClass, state) {
              tokens.push({
                text: text,
                styleClass: styleClass,
                state: state
              });
            });
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          callback({
            'tokens': tokens
          });
        });
        jsBridge.registerHandler('replaceCharacters', function(data, callback) {
          var e, endPos, event, pr, r, s, startPos;
          jsBridge.send('replacing ' + JSON.stringify(data.range) + ' with ' + data.string.substr(0, 5));
          try {
            s = data.string;
            r = CSRange.newRangeFromJSON(data.range);
            jsBridge.send('r: ' + JSON.stringify(r));
            startPos = doc.posFromIndex(r.location);
            endPos = doc.posFromIndex(r.maxEdge());
            pr = data.parseRange ? CSRange.newRangeFromJSON(data.parseRange) : void 0;
            event = data.event;
            if (event === 'keypress') {
              jsBridge.send('keypress');
            }
            if (pr) {
              parseRange = pr;
            }
            myCallback = callback;
            doc.replaceRange(s, startPos, endPos);
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
        });
        jsBridge.registerHandler('parse', function(_data, callback) {
          var data, e, r;
          try {
            r = CSRange.newRangeFromJSON(_data.range);
            data = {};
            data.mode = CMi.getMode().name;
            data.docLength = CMi.doc.getValue().length;
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          data.parseData = parse(r);
          callback(data);
        });
        parse = function(range) {
          var Counter, a, ar, as, attributedRanges, c, cssEl, e, gr, intersection, pos, sel, spanClass, token, tokens, tsl, _i, _j, _len, _loopEnd, _ref;
          try {
            jsBridge.send('parsing range ' + JSON.stringify(range.range()) + ' in mode: ' + JSON.stringify(CMi.getMode().name));
            as = new PPAttributedString({
              string: doc.getValue().substr(range.location, range.length)
            });
            tokens = [];
            attributedRanges = [];
            _i = range.location + 1;
            _loopEnd = range.maxEdge() + 1;
            Counter = (function() {
              function Counter(i, end) {
                this.i = i != null ? i : _i;
                this.end = end != null ? end : _loopEnd;
              }

              Counter.prototype.incrimentSafelyTo = function(new_i) {
                this.i = (new_i != null) && new_i > this.i ? new_i : this.i + 1;
              };

              return Counter;

            })();
            c = new Counter();
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          while (c.i < c.end) {
            pos = doc.posFromIndex(c.i);
            token = CMi.getTokenAt(pos, {
              precise: true
            });
            tsl = token.string.length;
            gr = new CSRange(doc.indexFromPos({
              line: pos.line,
              ch: token.start
            }), tsl);
            try {
              intersection = _.intersection(range.array(), gr.array());
              if (intersection.length !== tsl && intersection.length > 0) {
                gr.array(intersection);
              } else if (!gr.length === 0 && !_.intersection(range.array(), new CSRange(gr.location, 1).array()).length > 0) {
                jsBridge.send('Invalid token!');
                c.incrimentSafelyTo(gr.maxEdge() + 1);
                continue;
              }
              jsBridge.send('token string: ' + token.string);
              ar = attributedRanges[attributedRanges.push(new CSAttributedRange()) - 1];
              ar.range(gr.location - range.location, gr.length);
              jsBridge.send('lr: ' + JSON.stringify(ar.range()) + ' gr: ' + JSON.stringify(gr.range()));
              ar.m('globalRange', gr);
              a = ar.attributes;
              a.token = token;
              if (tsl > 0 && (a.token.type != null) && a.token.type !== void 0) {
                sel = [];
                _ref = token.className.split(' ');
                for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                  spanClass = _ref[_j];
                  sel.push('.cm-' + spanClass);
                }
                a.cssSelector = sel[sel.length - 1];
                cssEl = $(a.cssSelector);
                if (cssEl == null) {
                  jsBridge.send('There was a serious error trying to find selector "' + a.cssSelector + '".');
                } else if (cssEl.length === 0) {
                  jsBridge.send('No element could be found with the class "' + a.cssSelector + '". Trying ' + '"' + token.className + '" instead...');
                  cssEl = $(token.className);
                  if (cssEl.length === 0) {
                    jsBridge.send('No element could be found with the class "' + token.className + '" either.');
                  }
                }
                a.color = cssEl.css('color').replace(')', '(').split('(')[1].split(',');
                a.color = {
                  r: a.color[0],
                  g: a.color[1],
                  b: a.color[2]
                };
              } else {
                a.color = $('body').css('color').replace(')', '(').split('(')[1].split(',');
                a.color = {
                  r: a.color[0],
                  g: a.color[1],
                  b: a.color[2]
                };
              }
              jsBridge.send('attributes created at local range: ' + ar.location + ' ' + ar.length);
              tokens.push(token);
            } catch (_error) {
              e = _error;
              jsBridge.send(String(e));
            }
            c.incrimentSafelyTo(gr.maxEdge() + 1);
          }
          return {
            attributedString: as,
            tokens: tokens,
            range: range
          };
        };
        jsBridge.send('ready');
      });
    }
  ]).constant('routes', [
    {
      controller: 'MyCtrl1',
      resolve: {
        jsBridge: [
          'jsBridge', function(jsBridge) {
            return jsBridge;
          }
        ],
        myJQ: [
          'myJQ', function(myJQ) {
            return myJQ;
          }
        ]
      }
    }
  ]);

}).call(this);
