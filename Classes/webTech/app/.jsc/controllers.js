// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var parseRange;

  parseRange = null;

  angular.module('myApp.controllers', []).controller('MyCtrl1', [
    '$scope', 'jsBridge', 'CMi', 'CM', 'attributedContent', function($scope, jsBridge, CMi, CM, attributedContent) {
      CMi.then(function(CMi) {
        var doc, parse;
        $('html, body, .ng-view').css({
          'width': '100%',
          'height': '100%',
          'padding': '0',
          'margin': '0'
        });
        jsBridge.send('ready');
        doc = CMi.doc;
        CMi.on('change', function(myCM, change) {
          var as, data, e;
          try {
            data = {
              docLength: myCM.doc.getValue().length
            };
            if (parseRange) {
              as = parse(parseRange);
              data['attributedString'] = as;
            }
            parseRange = null;
            jsBridge.callHandler('action', data, function(data) {});
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
        });
        jsBridge.registerHandler('tokenize', function(data, callback) {
          var e, mode, returnData, string, tokens;
          mode = data.mode === 'scss' ? 'text/x-scss' : data.mode;
          string = data.string;
          if (!mode) {
            callback({
              errors: ['Error: no mode specified']
            });
            return;
          }
          jsBridge.send('tokenizing in ' + mode + ' mode...');
          tokens = [];
          try {
            CM.runMode(string, mode, function(text, styleClass, state) {
              if (text !== ' ' && text !== '' && text !== '\n' && text !== '\t') {
                tokens.push({
                  text: text,
                  styleClass: styleClass,
                  state: state
                });
              }
            });
            jsBridge.send(tokens.length + ' tokens collected.');
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          returnData = {
            'tokens': tokens
          };
          callback(returnData);
        });
        jsBridge.registerHandler('replaceCharacters', function(data, callback) {
          var e, endPos, mode, pr, r, startPos;
          jsBridge.send('replacing... ' + JSON.stringify(data));
          try {
            mode = data.mode === 'scss' ? 'text/x-scss' : data.mode;
            r = new NSRange(data.range.location, data.range.length);
            startPos = doc.posFromIndex(r.location);
            endPos = doc.posFromIndex(r.maxEdge());
            pr = data.parseRange;
          } catch (_error) {
            e = _error;
            jsBridge.send(String(e));
          }
          if (mode) {
            jsBridge.send('setting mode to ' + mode);
            CMi.setOption('mode', mode);
          }
          if (pr) {
            parseRange = new NSRange(pr.location, pr.length);
          }
          doc.replaceRange(data.string, startPos, endPos);
          callback({
            'message': true
          });
        });
        jsBridge.registerHandler('parse', function(data, callback) {
          jsBridge.send('doclength ' + docLength);
          callback({
            tokens: tokens,
            attributedRanges: attributedRanges,
            stringLength: docLength
          });
        });
        parse = function(range) {
          var as, color, cssEl, e, end, i, nooooo, pos, r, start, token, tokens, weird;
          as = new NSAttributedString(CMi.doc.getValue().substr(range.location, range.length));
          jsBridge.send('parsing in mode: ' + JSON.stringify(CMi.getMode().name));
          tokens = [];
          i = range.location > 0 ? range.location : 1;
          while (i < range.maxEdge()) {
            try {
              pos = doc.posFromIndex(i);
              token = CMi.getTokenAt(pos);
              start = doc.indexFromPos({
                line: pos.line,
                ch: token.start
              });
              end = start + (token.end - token.start);
              if (token.string.length > 0 && token.type !== null && token.type !== void 0) {
                jsBridge.send('trying ' + JSON.stringify(token));
                r = new NSAttributedRange();
                r.location = start;
                r.length = end - start;
                cssEl = $('.cm-' + token.type);
                color = cssEl.css('color').replace(')', '(').split('(')[1].split(',');
                $.extend(true, r.attributes, {
                  color: {
                    r: color[0],
                    g: color[1],
                    b: color[2]
                  }
                });
                as.attributedRanges.push(r);
                jsBridge.send('as created: ' + r.location + ' ' + r.length);
              } else {
                nooooo = true;
              }
              tokens.push(token);
            } catch (_error) {
              e = _error;
              jsBridge.send(String(e));
            }
            weird = end + 1;
            i = weird > i ? weird : i + 1;
          }
          return as;
        };
      });
    }
  ]).constant('routes', [
    {
      controller: 'MyCtrl1',
      resolve: {
        jsBridge: [
          'jsBridge', function(jsBridge) {
            return jsBridge;
          }
        ]
      }
    }
  ]);

}).call(this);
